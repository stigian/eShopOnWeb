name: Dotnet DevSecOps

on:
  push:
  pull_request:
    types: [opened]
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env: # TODO: swap these into the steps below, create more env as req'd
  dockerfile-path: './src/PublicApi/Dockerfile' # TODO: developer input, set based on manifest file
  target-url: 'http://localhost:80' # TODO: developer input, set based on manifest file
  image-name: 'publicapi' # TODO: developer input, set based on manifest file
  container-port: '5200'

jobs:
  build_and_test:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout This Repository
        uses: actions/checkout@v4

      # TODO: This step is not required if the composite actions are in a public
      # repository. Adjust accordingly once the composite actions are public.
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: stigian/archimedes-workflows-dotnet
          ref: init # Branch, tag, or SHA
          path: ./composite
          token: ${{ secrets.ACTIONS_PAT }}

      - name: Build and Test
        uses: ./composite/.github/actions/build-and-test
        with:
          # dotnet-version: '8.0' # Developer must specify versions in global.json
          global-json-path: './global.json'
          sln-path: './eShopOnWeb.sln'

  sast:
    name: SAST
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      actions: read
      contents: read
      security-events: write

    steps:
      - name: Checkout This Repository
        uses: actions/checkout@v4

      # TODO: This step is not required if the composite actions are in a public
      # repository. Adjust accordingly once the composite actions are public.
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: stigian/archimedes-workflows-dotnet
          ref: init
          path: ./composite
          token: ${{ secrets.ACTIONS_PAT }}

      - name: Static Application Security Test
        uses: ./composite/.github/actions/sast
        with:
          languages: 'csharp'
          source-path: './src'
          fail-on-findings: 'false' # TODO: set based on environment, or dev input

  image_scan:
    # needs: [build_and_test, sast]
    name: Image Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read # useful in case we want to pull an image from GHCR
      security-events: write
      # id-token: write # not required until sign_and_sbom

    # Composite action scans one image at a time, so we can use a matrix in the caller workflow
    # to scan multiple images in parallel.
    # TODO: figure out how to handle multiple dockerfile-paths and image name relationships
    #   strategy:
    #     matrix: # TODO: developer input, set according to manifest file
    #       image:
    #         - Web
    #         - PublicApi

    steps:

      - name: Checkout Repository
        uses: actions/checkout@v4

      # TODO: This step is not required if the composite actions are in a public
      # repository. Adjust accordingly once the composite actions are public.
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: stigian/archimedes-workflows-dotnet
          ref: init
          path: ./composite
          token: ${{ secrets.ACTIONS_PAT }}

    #   # # Todo: not required unless push: true in build-push-action
    #   # - name: Login to ghcr.io
    #   #   uses: docker/login-action@v3
    #   #   with:
    #   #     registry: ghcr.io
    #   #     username: ${{ github.actor }}
    #   #     password: ${{ secrets.GITHUB_TOKEN }}

    #   - name: Convert Image Name to Lowercase
    #     id: lowercase
    #     run: echo "IMAGE_NAME=$(echo "${{ github.repository }}/${{ matrix.image }}" | awk '{print tolower($0)}')" >> $GITHUB_OUTPUT

      - name: Scan Container Image
        uses: ./composite/.github/actions/image-scan
        with:
          dockerfile-path: './src/PublicApi/Dockerfile' # TODO: developer input, set based on manifest file
          image-name: 'publicapi'
          # image-tag: 'latest'
          # fail-on-findings: 'true'
          # severity-displayed: 'CRITICAL'
          # ignore-path: './.trivyignore'

  dast:
    # needs: [image_scan] # TODO: add back prerequisites
    name: DAST
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
  #   strategy:
  #     matrix: # TODO: developer input, set according to manifest file
  #       image:
  #         - Web
  #         - PublicAPI

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # TODO: This step is not required if the composite actions are in a public
      # repository. Adjust accordingly once the composite actions are public.
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: stigian/archimedes-workflows-dotnet
          ref: init
          path: ./composite
          token: ${{ secrets.ACTIONS_PAT }}

      - name: Dynamic Application Security Test
        uses: ./composite/.github/actions/dast
        with:
          dockerfile-path: './src/PublicApi/Dockerfile' # TODO: developer input, set based on manifest file
          target-url: 'http://localhost' # TODO: developer input, set based on manifest file
          image-name: 'publicapi' # TODO: developer input, set based on manifest file
          container-port: '80' # TODO: developer input, set based on manifest file, mapped to port 80 on the runner
          # image-name: 'web' # TODO: developer input, set based on manifest file
          # image-tag: 'latest'
          # scan-severity-threshold: 'HIGH'


  # sign_and_sbom:
  #   needs: [dast]
  #   name: Sign and SBOM
  #   runs-on: ubuntu-latest
  #   permissions:
  #     contents: read
  #     packages: write
  #     id-token: write # needed for signing the images with GitHub OIDC Token
  #   strategy:
  #     matrix: # TODO: developer input, set according to manifest file
  #       image:
  #         - Web
  #         - PublicApi

  #   steps:
  #   - name: Checkout Repository
  #     uses: actions/checkout@v4
  #     with:
  #       fetch-depth: 1

  #   # TODO: research if we can change auth to use GitHub app instead of PAT
  #   - name: Login to ghcr.io
  #     uses: docker/login-action@v3
  #     with:
  #       registry: ghcr.io
  #       username: ${{ github.actor }}
  #       password: ${{ secrets.RPOC_PAT }}

  #   # Convert to lowercase for ghcr.io
  #   # This step can be eliminated if we enforce lowercase image names in the manifest
  #   - name: Format Image Names
  #     id: lowercase
  #     run: echo "IMAGE_NAME=$(echo "${{ github.repository }}/${{ matrix.image }}" | awk '{print tolower($0)}')" >> $GITHUB_OUTPUT

  #   # Todo: spend more time fine-tuning the metadata-action to fit tagging requirements
  #   # Note that the priority flag will determine the order of tags in the metadata
  #   # https://github.com/docker/metadata-action?tab=readme-ov-file#priority-attribute
  #   - name: Generate GHCR Metadata
  #     id: docker_meta
  #     uses: docker/metadata-action@v5
  #     with:
  #       images: ghcr.io/${{ steps.lowercase.outputs.IMAGE_NAME }}
  #       tags: |
  #         type=sha,format=long,prefix=,suffix=,priority=850
  #         type=raw,value=main,enable=${{ github.ref == format('refs/heads/{0}', 'main') }}
  #       labels: |
  #         org.opencontainers.image.source=https://github.com/${{ github.repository }}

  #   - name: Save Image Tag
  #     run: echo "${{ steps.docker_meta.outputs.tags }}" | head -n 1 > image-tag-${{ matrix.image }}.txt

  #   # Upload image tags to be used by other jobs in this workflow
  #   - name: Upload Image Tags
  #     uses: actions/upload-artifact@v4
  #     with:
  #       name: image-tag-${{ matrix.image }}
  #       path: image-tag-${{ matrix.image }}.txt

  #   # TODO: developer input, set according to manifest file
  #   - name: Build and Push ${{ matrix.image }} to ghcr.io
  #     id: build-and-push
  #     uses: docker/build-push-action@v5
  #     with:
  #       platforms: linux/amd64
  #       context: .
  #       file: ./src/${{ matrix.image }}/Dockerfile
  #       push: true
  #       tags: ${{ steps.docker_meta.outputs.tags }}
  #       # tags: |
  #       #   ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}
  #       #   ghcr.io/${{ env.IMAGE_NAME }}:latest
  #       labels: ${{ steps.docker_meta.outputs.labels }}
  #       # labels: |
  #       #   org.opencontainers.image.source=https://github.com/${{ github.repository }}

  #   - name: Install Cosign
  #     uses: sigstore/cosign-installer@v3.4.0
  #     with:
  #       cosign-release: 'v2.2.3' # optional

  #   - name: Verify Cosign Version
  #     run: cosign version

  #   # This is a short-lived key that won't be easy to verify by downstream consumers
  #   # Technically the actions runner is signing the image, not an individual or organization
  #   # Instead, we may wish to use a private key signing method, as shown in the commented
  #   # out example below.
  #   - name: Sign the Images with GitHub OIDC Token
  #     env:
  #       DIGEST: ${{ steps.build-and-push.outputs.digest }}
  #       TAGS: ${{ steps.docker_meta.outputs.tags }}
  #     run: |
  #       images=""
  #       for tag in ${TAGS}; do
  #         images+="${tag}@${DIGEST} "
  #       done
  #       cosign sign --yes ${images}

  #   # # https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-an-intermediate-environment-variable
  #   # - name: Sign image with a key
  #   #   run: |
  #   #     images=""
  #   #     for tag in ${TAGS}; do
  #   #       images+="${tag}@${DIGEST} "
  #   #     done
  #   #     cosign sign --yes --key env://COSIGN_PRIVATE_KEY ${images}
  #   #   env:
  #   #     TAGS: ${{ steps.docker_meta.outputs.tags }}
  #   #     COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
  #   #     COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
  #   #     DIGEST: ${{ steps.build-and-push.outputs.digest }}

  #   - name: Generate SBOM
  #     uses: anchore/sbom-action@v0
  #     with:
  #       image: ghcr.io/${{ steps.lowercase.outputs.IMAGE_NAME }}:${{ github.sha }}
  #       artifact-name: sbom-${{ matrix.image }}-${{ github.sha }}.spdx.json
  #       upload-artifact: true

  # deploy_prod:
  #   if: github.ref == 'refs/heads/main'
  #   needs: [sign_and_sbom]
  #   environment: production
  #   name: Deploy to Production Registry
  #   runs-on: ubuntu-latest
  #   permissions:
  #     contents: read
  #     packages: read  # needed to pull image from GHCR
  #     id-token: write # needed to access the GitHub OIDC token
  #   strategy:
  #     matrix: # TODO: developer input, set according to manifest file
  #       image:
  #         - Web
  #         - PublicApi
  #   env: # TODO: set as Actions secrets/variables
  #     AWS_REGION: us-gov-west-1
  #     AWS_ROLE: arn:aws-us-gov:iam::348600370629:role/github-actions-ecr-role

  #   steps:
  #   - name: Checkout Repository
  #     uses: actions/checkout@v4

  #   - name: Get Image Tag Artifact
  #     uses: actions/download-artifact@v4
  #     with:
  #       name: image-tag-${{ matrix.image }}
  #       path: . # Extract artifact to current directory

  #   - name: Read Image Tag
  #     id: read_tag
  #     run: echo "GHCR_TAG=$(cat image-tag-${{ matrix.image }}.txt)" >> $GITHUB_OUTPUT

  #   - name: Format Image Names
  #     id: lowercase
  #     run: echo "ECR_TAG=$(echo "${{ github.repository }}/${{ matrix.image }}" | awk '{print tolower($0)}')" >> $GITHUB_OUTPUT

  #   - name: Configure AWS Credentials for GovCloud
  #     uses: aws-actions/configure-aws-credentials@v4
  #     with:
  #       audience: sts.amazonaws.com
  #       aws-region: ${{ env.AWS_REGION }}
  #       role-to-assume: ${{ env.AWS_ROLE }}
  #       # role-session-name: GitHubActions-${{ github.actor }}

  #   - name: Login to ghcr.io
  #     uses: docker/login-action@v3
  #     with:
  #       registry: ghcr.io
  #       username: ${{ github.actor }}
  #       password: ${{ secrets.GITHUB_TOKEN }}

  #   - name: Login to Amazon ECR
  #     id: login-ecr
  #     uses: aws-actions/amazon-ecr-login@v2
  #     with:
  #       registry-type: private

  #   # This step feels like it could be revised for clarity, but I need to test some variations separately
  #   # ECR naming convention is different from GHCR, each ECR repo corresponds to a single image
  #   # https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-create.html
  #   #   ECR_REPO_NAME: ${{ github.repository }}
  #   #   ECR_IMAGE_NAME: ${{ matrix.image }}
  #   - name: Push to Amazon ECR
  #     env:
  #       ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
  #     run: |
  #       docker pull ${{ steps.read_tag.outputs.GHCR_TAG }}
  #       docker tag ${{ steps.read_tag.outputs.GHCR_TAG }} $ECR_REGISTRY/${{ steps.lowercase.outputs.ECR_TAG }}:${{ github.sha }}
  #       docker push $ECR_REGISTRY/${{ steps.lowercase.outputs.ECR_TAG }}:${{ github.sha }}
