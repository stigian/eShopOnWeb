name: Archimedes - Dotnet

on:
  push:
  pull_request:
    types: [opened]
    branches: [main]
  workflow_dispatch:

# Concurrency settings will cancel any in-progress run if new code is pushed.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env: # TODO: swap these into the steps below, create more env as req'd
  dockerfile-path: './src/PublicApi/Dockerfile' # TODO: developer input, set based on manifest file
  target-url: 'http://localhost:80' # TODO: developer input, set based on manifest file
  image-name: 'publicapi' # TODO: developer input, set based on manifest file
  container-port: '5200'

jobs:
  build_and_test:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout This Repository
        uses: actions/checkout@v4

      # TODO: This step is not required if the composite actions are in a public
      # repository. Adjust accordingly once the composite actions are public.
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: stigian/archimedes-workflows-dotnet
          ref: init # Branch, tag, or SHA
          path: ./composite
          token: ${{ secrets.ACTIONS_PAT }}

      - name: Build and Test
        uses: ./composite/.github/actions/build-and-test
        with:
          # dotnet-version: '8.0' # Developer must specify versions in global.json
          global-json-path: './global.json'
          sln-path: './eShopOnWeb.sln'

  sast:
    name: SAST
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      actions: read
      contents: read
      security-events: write

    steps:
      - name: Checkout This Repository
        uses: actions/checkout@v4

      # TODO: This step is not required if the composite actions are in a public
      # repository. Adjust accordingly once the composite actions are public.
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: stigian/archimedes-workflows-dotnet
          ref: init
          path: ./composite
          token: ${{ secrets.ACTIONS_PAT }}

      - name: Static Application Security Test
        uses: ./composite/.github/actions/sast
        with:
          languages: 'csharp'
          source-path: './src'
          fail-on-findings: 'false' # TODO: set based on environment, or dev input

  image_scan:
    # needs: [build_and_test, sast]
    name: Image Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read # useful in case we want to pull an image from GHCR
      security-events: write
      # id-token: write # not required until sign_and_sbom

    # Composite action scans one image at a time, so we can use a matrix in the caller workflow
    # to scan multiple images in parallel.
    # TODO: figure out how to handle multiple dockerfile-paths and image name relationships
    strategy:
      matrix: # TODO: developer input, set according to manifest file
        include:
          - image-name: 'eshoppublicapi'
            dockerfile-path: './src/PublicApi/Dockerfile'
          - image-name: 'eshopwebmvc'
            dockerfile-path: './src/Web/Dockerfile'

    steps:

      - name: Checkout Repository
        uses: actions/checkout@v4

      # TODO: This step is not required if the composite actions are in a public
      # repository. Adjust accordingly once the composite actions are public.
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: stigian/archimedes-workflows-dotnet
          ref: init
          path: ./composite
          token: ${{ secrets.ACTIONS_PAT }}

    #   # # Todo: not required unless push: true in build-push-action
    #   # - name: Login to ghcr.io
    #   #   uses: docker/login-action@v3
    #   #   with:
    #   #     registry: ghcr.io
    #   #     username: ${{ github.actor }}
    #   #     password: ${{ secrets.GITHUB_TOKEN }}

    #   - name: Convert Image Name to Lowercase
    #     id: lowercase
    #     run: echo "IMAGE_NAME=$(echo "${{ github.repository }}/${{ matrix.image }}" | awk '{print tolower($0)}')" >> $GITHUB_OUTPUT

      - name: Scan Container Image
        uses: ./composite/.github/actions/image-scan
        with:
          dockerfile-path: ${{ matrix.dockerfile-path }} # TODO: developer input, set based on manifest file
          image-name: ${{ matrix.image-name }} # TODO: developer input, set based on manifest file
          # image-tag: 'latest'
          # fail-on-findings: 'true'
          # severity-displayed: 'CRITICAL'
          # ignore-path: './.trivyignore'

  dast:
    needs: [image_scan]
    name: DAST
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    strategy:
      matrix: # TODO: developer input, set according to manifest file
        include:
          - image-name: 'eshopwebmvc'
            target-url: 'http://localhost:5106'
            host-port: '5106'
            container-port: '8080'
            startup-time: '30'
          - image-name: 'eshoppublicapi'
            target-url: 'http://localhost:5200'
            host-port: '5200'
            container-port: '8080'
            startup-time: '30'

    steps:

      - name: Checkout This Repository
        uses: actions/checkout@v4

      # TODO: This step is not required if the composite actions are in a public
      # repository. Adjust accordingly once the composite actions are public.
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: stigian/archimedes-workflows-dotnet
          ref: init
          path: ./composite
          token: ${{ secrets.ACTIONS_PAT }}

      # Documentation:
      #   - docker-compose-path: the repo path to the docker-compose.yml file, default is ./docker-compose.yml
      #   - target-url: the URL where the container is listening, format http://localhost:{host-port}/{path}
      #   - image-name: friendly name of the image to scan, no effect on image publishing
      #   - host-port: the port the host should listen on, 1024 to 65535, default is 8080
      #   - container-port: the port the container is listening on
      #   - fail-on-findings: whether to fail the action if findings are found, default is false
      #   - startup-time: time in seconds to wait for the container to start
      - name: Dynamic Application Security Test
        uses: ./composite/.github/actions/dast
        with:
          docker-compose-path: './docker-compose.yml'
          target-url: ${{ matrix.target-url }}
          image-name: ${{ matrix.image-name }} # TODO: developer input, set based on manifest file
          host-port: ${{ matrix.host-port}} # TODO: developer input, set based on manifest file
          container-port: ${{ matrix.container-port }} # TODO: developer input, set based on manifest file, mapped to port 80 on the runner
          fail-on-findings: 'false' # TODO: select based on deployment env (prod vs dev)
          startup-time: ${{ matrix.startup-time }} # Time in seconds to wait for the container to start

  publish:
    needs: [sast,dast]
    name: Publish
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write # needed for signing the images with GitHub OIDC Token
      attestations: write
    strategy:
      matrix: # TODO: developer input, set according to manifest file
        image:
          - image-name: 'eshoppublicapi'
            dockerfile-path: './src/PublicApi/Dockerfile'
          - image-name: 'eshopwebmvc'
            dockerfile-path: './src/Web/Dockerfile'
    steps:

      - name: Checkout This Repository
        uses: actions/checkout@v4

      # TODO: This step is not required if the composite actions are in a public
      # repository. Adjust accordingly once the composite actions are public.
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: stigian/archimedes-workflows-dotnet
          ref: init
          path: ./composite
          token: ${{ secrets.ACTIONS_PAT }}

      - name: Publish Image
        uses: ./composite/.github/actions/publish
        with:
          dockerfile-path: ${{ matrix.dockerfile-path }} # TODO: developer input, set based on manifest file
          docker-build-context: '.' # TODO: developer input, set based on manifest file
          image-name: ${{ matrix.image-name }} # TODO: developer input, set based on manifest file
          token: ${{ secrets.GITHUB_TOKEN }}

  # deploy_prod:
  #   if: github.ref == 'refs/heads/main'
  #   needs: [sign_and_sbom]
  #   environment: production
  #   name: Deploy to Production Registry
  #   runs-on: ubuntu-latest
  #   permissions:
  #     contents: read
  #     packages: read  # needed to pull image from GHCR
  #     id-token: write # needed to access the GitHub OIDC token
  #   strategy:
  #     matrix: # TODO: developer input, set according to manifest file
  #       image:
  #         - Web
  #         - PublicApi
  #   env: # TODO: set as Actions secrets/variables
  #     AWS_REGION: us-gov-west-1
  #     AWS_ROLE: arn:aws-us-gov:iam::348600370629:role/github-actions-ecr-role

  #   steps:
  #   - name: Checkout Repository
  #     uses: actions/checkout@v4

  #   - name: Get Image Tag Artifact
  #     uses: actions/download-artifact@v4
  #     with:
  #       name: image-tag-${{ matrix.image }}
  #       path: . # Extract artifact to current directory

  #   - name: Read Image Tag
  #     id: read_tag
  #     run: echo "GHCR_TAG=$(cat image-tag-${{ matrix.image }}.txt)" >> $GITHUB_OUTPUT

  #   - name: Format Image Names
  #     id: lowercase
  #     run: echo "ECR_TAG=$(echo "${{ github.repository }}/${{ matrix.image }}" | awk '{print tolower($0)}')" >> $GITHUB_OUTPUT

  #   - name: Configure AWS Credentials for GovCloud
  #     uses: aws-actions/configure-aws-credentials@v4
  #     with:
  #       audience: sts.amazonaws.com
  #       aws-region: ${{ env.AWS_REGION }}
  #       role-to-assume: ${{ env.AWS_ROLE }}
  #       # role-session-name: GitHubActions-${{ github.actor }}

  #   - name: Login to ghcr.io
  #     uses: docker/login-action@v3
  #     with:
  #       registry: ghcr.io
  #       username: ${{ github.actor }}
  #       password: ${{ secrets.GITHUB_TOKEN }}

  #   - name: Login to Amazon ECR
  #     id: login-ecr
  #     uses: aws-actions/amazon-ecr-login@v2
  #     with:
  #       registry-type: private

  #   # This step feels like it could be revised for clarity, but I need to test some variations separately
  #   # ECR naming convention is different from GHCR, each ECR repo corresponds to a single image
  #   # https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-create.html
  #   #   ECR_REPO_NAME: ${{ github.repository }}
  #   #   ECR_IMAGE_NAME: ${{ matrix.image }}
  #   - name: Push to Amazon ECR
  #     env:
  #       ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
  #     run: |
  #       docker pull ${{ steps.read_tag.outputs.GHCR_TAG }}
  #       docker tag ${{ steps.read_tag.outputs.GHCR_TAG }} $ECR_REGISTRY/${{ steps.lowercase.outputs.ECR_TAG }}:${{ github.sha }}
  #       docker push $ECR_REGISTRY/${{ steps.lowercase.outputs.ECR_TAG }}:${{ github.sha }}
