name: Sign and SBOM

on:
  workflow_dispatch:
  push:
    branches:
      - main

env:
  AWS_REGION: us-gov-west-1

jobs:
  sign_and_sbom:
    name: Sign and SBOM
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write # needed for signing the images with GitHub OIDC Token
    strategy:
      matrix:
        image:
          - Web
          - PublicApi
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 1

    # TODO: research if we can change auth to use GitHub app instead of PAT
    - name: Login to ghcr.io
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.RPOC_PAT }}

    # Convert to lowercase for ghcr.io
    # This step can be eliminated if we enforce lowercase image names in the manifest
    - name: Format image names
      run: echo "IMAGE_NAME=$(echo "${{ github.repository }}/${{ matrix.image }}" | awk '{print tolower($0)}')" >> $GITHUB_ENV

    # Need to decide how to handle latest tag. Should it be on every branch, or just main, or just releases?
    # For now we put it on main for testing purposes.
    - name: Generate GHCR Metadata
      id: docker_meta
      uses: docker/metadata-action@v5
      with:
        images: ghcr.io/${{ env.IMAGE_NAME }}
        tags: |
          type=sha,format=long,prefix=,suffix=
          type=raw,value=latest,enable=${{ github.ref == format('refs/heads/{0}', 'main') }}
        labels: |
          org.opencontainers.image.source=https://github.com/${{ github.repository }}

    - name: Save image tags
      run: echo "${{ steps.docker_meta.outputs.tags }}" > imagetags.txt

    - name: Upload image tags
      uses: actions/upload-artifact@v4
      with:
        name: image-tags
        path: imagetags.txt

    # TODO: consider project structure, where dockerfile might be, how devs might provide manifests, etc.
    # TODO: add more tags as needed, e.g. branch, actions environment
    - name: Build and Push ${{ matrix.image }} to ghcr.io
      id: build-and-push
      uses: docker/build-push-action@v5
      with:
        platforms: linux/amd64
        context: .
        file: ./src/${{ matrix.image }}/Dockerfile
        push: true
        tags: ${{ steps.docker_meta.outputs.tags }}
        # tags: |
        #   ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}
        #   ghcr.io/${{ env.IMAGE_NAME }}:latest
        labels: ${{ steps.docker_meta.outputs.labels }}
        # labels: |
        #   org.opencontainers.image.source=https://github.com/${{ github.repository }}

    - name: Install Cosign
      uses: sigstore/cosign-installer@v3.4.0
      with:
        cosign-release: 'v2.2.3' # optional

    - name: Verify Cosign version
      run: cosign version

    # This is a short-lived key that won't be easy to verify by downstream consumers
    # Technically the actions runner is signing the image, not an individual or organization
    # Instead, we may wish to use a private key signing method, as shown in the commented
    # out example below.
    - name: Sign the images with GitHub OIDC Token
      env:
        DIGEST: ${{ steps.build-and-push.outputs.digest }}
        TAGS: ${{ steps.docker_meta.outputs.tags }}
      run: |
        images=""
        for tag in ${TAGS}; do
          images+="${tag}@${DIGEST} "
        done
        cosign sign --yes ${images}

    # # https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-an-intermediate-environment-variable
    # - name: Sign image with a key
    #   run: |
    #     images=""
    #     for tag in ${TAGS}; do
    #       images+="${tag}@${DIGEST} "
    #     done
    #     cosign sign --yes --key env://COSIGN_PRIVATE_KEY ${images}
    #   env:
    #     TAGS: ${{ steps.docker_meta.outputs.tags }}
    #     COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
    #     COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
    #     DIGEST: ${{ steps.build-and-push.outputs.digest }}

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}
        artifact-name: sbom-${{ matrix.image }}-${{ github.sha }}.spdx.json
        upload-artifact: true

    - name: Configure AWS Credentials for GovCloud
      uses: aws-actions/configure-aws-credentials@v4
      with:
        audience: sts.amazonaws.com
        aws-region: ${{ env.AWS_REGION }}
        role-to-assume: arn:aws-us-gov:iam::348600370629:role/github-actions-ecr-role
        role-session-name: GitHubActions-${{ github.actor }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      with:
        registry-type: private

    # Images are already built in previous step, so we just need to re-tag and push them to ECR
    # ECR naming convention is different from GHCR, each ECR repo corresponds to a single image
    # https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-create.html
    # Will need to coordinate ECR repo naming to GitHub repo naming so that we can reuse variables
    # in this workflow, like:
    #   ECR_REPO_NAME: ${{ github.repository }}
    #   ECR_IMAGE_NAME: ${{ matrix.image }}
    - name: Push to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        docker tag ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }} $ECR_REGISTRY/${{ env.IMAGE_NAME }}:${{ github.sha }}
        docker push $ECR_REGISTRY/${{ env.IMAGE_NAME }}:${{ github.sha }}

